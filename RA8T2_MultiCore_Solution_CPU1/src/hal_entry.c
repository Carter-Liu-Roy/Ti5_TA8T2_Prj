#include "hal_data.h"
#include "ecat_def.h"
#include "ecatappl.h"
#include "ecatslv.h"
#include "applInterface.h"
#if (CiA402_SAMPLE_APPLICATION == 1)
#include "cia402appl.h"
#else
#include "sampleappl.h"
#endif
#include "renesashw.h"
#if (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
bsp_ipc_semaphore_handle_t g_core_start_semaphore =
{
    .semaphore_num = 0
};
#endif

uint8_t g_callback_called;
uint32_t g_last_message_received;
uint32_t g_last_message_send;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */

    /* Wake up 2nd core if this is first core and we are inside a multicore project. */
#if (0 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && !BSP_TZ_NONSECURE_BUILD

#if BSP_TZ_SECURE_BUILD
    /* Take semaphore so 2nd core can clear it */
    R_BSP_IpcSemaphoreTake(&g_core_start_semaphore);
#endif

    R_BSP_SecondaryCoreStart();

#if BSP_TZ_SECURE_BUILD
    /* Wait for 2nd core to start and clear semaphore */
    while(FSP_ERR_IN_USE == R_BSP_IpcSemaphoreTake(&g_core_start_semaphore))
    {
        ;
    }
#endif
#endif

#if (1 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
    /* Signal to 1st core that 2nd core has started */
    R_BSP_IpcSemaphoreGive(&g_core_start_semaphore);
#endif


#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
    fsp_err_t err;
    R_IPC_Open(&g_ipc0_ctrl, &g_ipc0_cfg);//0: receive data from core 0
    R_IPC_Open(&g_ipc1_ctrl, &g_ipc1_cfg);//1: send data yo core 0
     
    err = RM_ETHERCAT_SSC_PORT_Open(gp_ethercat_ssc_port->p_ctrl, gp_ethercat_ssc_port->p_cfg);
    if(FSP_SUCCESS != err)
    {
        __BKPT(0);
    }
    
        MainInit();

#if (CiA402_SAMPLE_APPLICATION == 1)
    /* Initialize axis structures */
    CiA402_Init();
#endif
     __enable_irq();
    /* Create basic mapping */
    APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
    /* Set stack run flag */
    bRunApplication = TRUE;
    
    /* Execute the stack */
    while(bRunApplication == TRUE)
    {
        MainLoop();
        
        if(g_callback_called) /* Wait for message from callback */
        {
          g_callback_called = 0;
          g_last_message_send = g_last_message_received; /* Message will be in g_last_message_received */
          R_IPC_MessageSend(&g_ipc1_ctrl, g_last_message_send);
          g_last_message_received = 0;
          g_last_message_send = 0;
        }

   
   
    }

#if (CiA402_SAMPLE_APPLICATION == 1)
    /* Remove all allocated axes resources */
    CiA402_DeallocateAxis();
#endif

    RM_ETHERCAT_SSC_PORT_Close(gp_ethercat_ssc_port->p_ctrl);

    
    
}

void g_ipc0_callback (ipc_callback_args_t * p_args)//receive
{
    /* Check for message received event */
    if (IPC_EVENT_MESSAGE_RECEIVED & p_args->event)
    {
        g_callback_called       = true;
        g_last_message_received = p_args->message;
    }
}

void g_ipc1_callback (ipc_callback_args_t * p_args)//send
{
    /* Check for message send event */

}


#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
